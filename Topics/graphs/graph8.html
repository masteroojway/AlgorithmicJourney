<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Graphs - 8</h1>
    <h2>Covered in this section:</h2>
    <ul>
        <li>Single source shortest paths (SSSP)</li>
        <li>Dijkstra's Algorithm</li>
        <li>Bellman-Ford Algorithm</li>
    </ul>
    <h2>SSSP Motivation</h2>
    <p>
        Problem Statement: Given a weighted graph G and source vertex s, what are the shortest paths from s to all other vertices
        of G? One example of shortest single source path algorithm is Maps, getting you from one point to another in the 
        shortest time possible of shortest distance possible. It is done by two popular algorithms:
    </p>
    <ul>
        <li>Dijkstra's algorithm: use for non negative edge weights</li>
        <li>Bellman-Ford algorithm: used for positive and negative edges but has worse timecomplexity then dijkstra</li>
    </ul>
    <p>
        <strong>Weighted graphs</strong>: is graph where each edge is assigned a numerical value. The edge from a node to itself is
        of weight 0. We generally store the weight is takes to get to a node in the node itself. Therefore initially weight of source = 0 and 
        weight of all other nodes = infinity and then we traverse the graph and try to get weights of nodes as less as possible.
    </p>
    <p>
        Mostly we maintain two vectors to solve this kind of problems:
    </p>
    <ul>
        <li>d[v]: value inside nodes representing current distance from source.</li>
        <li>pi[v]: value of parent node on current best path from source to that node. pi[source] = nil</li>
    </ul>
    <p>
        When negative weights come into the picture, we have to consider negative cycles:
    </p>
    <img src="./pictures/graph9.png" height="300px">
    <p>
        the above example has the potential to cause an infinite loop in your code and traversing that cycle cause a net reduction 
        in node wieght every single time therefore it will keep on decreasing. Bellman ford algorithm has to detect cycles too therefore
        it has more complexity then dijkstra.
    </p>
    <p>
        Edge relaxation: relaxing an edge means trying to improve the shortest distance to en edge. <br />
        if <strong> d[v] > d[u] + w(u,v)</strong> then update d[v] and update parent in shortest pi[v].
        Repeat this until all d[v] &lt; = d[u] + w(u,v). <br/>
        This is a general bruteforce algorithm that will work for graphs without negative cycles.
    </p>
    <p>
        If you see a directed acyclic graph (DAG) and you know it is a SSSP problem, then one pass over vertices from left to right
        applying edge relaxation will solve your SSSP problem.
    </p>
    <h2>Dijkstra's algorithm</h2>
    <p>
        we have two sets in this alogithm <br />
        <ul>
            <li>Q: contains elements that we dont know the shortest path to. initialized to all vertices</li>
            <li>S: contains elements that we know the shortest path to. initialized to NULL</li>
        </ul>
        dijkstra source code:
    </p>
    <pre><code>
        initialize all vertices to infinity except source. Initialize source to zero. and put all of these vertices in q;
        while(!q.empty())
        {
            ll u = EXTRACT-MIN(q);
            delete u from q;
            s.push_back(u);
            for(auto i: adj[u])
            {
                relax(u,i);
            }
        }
    </code></pre>
    <h2>Bellman-Ford Algorithm</h2>
    <p>
        this is a generic shortest path algorithm which works for negative edges too and detects negative cycles. If negative cycles are
        present in the graph it aborts the process.
    </p>
</body>
</html>