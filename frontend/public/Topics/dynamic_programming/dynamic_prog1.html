<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <section>
        <h1>Dynamic Programming - 1</h1>
        <h2>Covered in this section: </h2>
        <ul>
          <li>Fundamentals and core concepts of Dynamic Programming</li>
        </ul>
      </section>
      <h2>Introduction</h2>
      <p>
        Dynamic Programming (DP) is a powerful problem-solving technique used in computer science to solve complex problems
        by breaking them down into simpler, overlapping subproblems. It is primarily an optimization over plain recursion,
        where previously computed results are reused to avoid redundant and repeated computations.
      </p>
      <p>
        Dynamic Programming is commonly used for:
        <ul>
          <li>Finding the optimal solution to a problem (e.g., minimum/maximum value, longest path, etc.)</li>
          <li>Counting the total number of possible solutions (e.g., number of ways to reach a target)</li>
        </ul>
      </p>
      <h2>Memoization (Top-Down DP)</h2>
      <p>
        Memoization in a technique in dynamic programming where you solve a subproblem only once and then save the result in a look-up table.
        Typically we try to save states in a vector or an array because look-up time is <code>O(1)</code>. However you can use <code>map</code> or
        <code>unordered_map</code> to store states too.
      </p>
       <pre><code>
  // DP solution of Fibonacci using vector:
  vector&lt;int&gt; dp;

  int fib(int n) {
      if (dp[n] != -1) return dp[n];
      if (n == 0) return dp[n] = 0;
      if (n == 1) return dp[n] = 1;
      return dp[n] = fib(n - 1) + fib(n - 2);
  }

  int main() {
      int n = 10;
      dp.assign(n + 1, -1);
      int result = fib(n);
      return 0;
  }

</code></pre>
      <h2>Tabulation (Bottom-Up DP)</h2>
      <p>
        Tabulation is exactly the opposite of Top-Down DP. You start with the base case and build up to your answer. Here
        is an example for calculating Fibonacci numbers using tabulation.
      </p>

<pre><code>
  // Fibonacci using Tabulation (Bottom-Up DP)
  int fibonacci(int n) {
      if (n == 0) return 0;
      vector&lt;int&gt; dp(n + 1);
      dp[0] = 0;
      dp[1] = 1;
      
      for (int i = 2; i &lt;= n; ++i) {
          dp[i] = dp[i - 1] + dp[i - 2];
      }
      
      return dp[n];
  }

  int main() {
      int n = 10;
      cout &lt;&lt; "Fibonacci(" &lt;&lt; n &lt;&lt; ") = " &lt;&lt; fibonacci(n) &lt;&lt; endl;
      return 0;
  }

</code></pre>
      <h3>Tabulation vs Memoization</h3>
<table border="1" cellspacing="0" cellpadding="10">
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Tabulation (Bottom-Up)</th>
      <th>Memoization (Top-Down)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Approach</td>
      <td>Iterative (Bottom-Up)</td>
      <td>Recursive (Top-Down)</td>
    </tr>
    <tr>
      <td>Function Call Overhead</td>
      <td>No function calls — faster</td>
      <td>Has recursive calls — slower due to overhead</td>
    </tr>
    <tr>
      <td>Risk of Stack Overflow</td>
      <td>None — uses loops</td>
      <td>Possible for large inputs due to recursion depth</td>
    </tr>
    <tr>
      <td>Space Optimization</td>
      <td>Easy to optimize (e.g., O(1) space in Fibonacci)</td>
      <td>Harder to optimize — call stack takes extra space</td>
    </tr>
    <tr>
      <td>Execution Order</td>
      <td>Subproblems solved in fixed order</td>
      <td>Subproblems solved on-demand as needed</td>
    </tr>
    <tr>
      <td>Ease of Implementation</td>
      <td>Sometimes more verbose</td>
      <td>Often shorter and more intuitive</td>
    </tr>
    <tr>
      <td>Cache Locality</td>
      <td>Better (data accessed in sequence)</td>
      <td>Poorer (random access via recursion)</td>
    </tr>
  </tbody>
</table>

  <p>
    Despite having similar theoretical time and space complexities, tabulation is often preferred—and sometimes even necessary—over memoization due to practical constraints. 
    Memoization can introduce overhead from recursive calls, redundant state evaluations, or deep recursion stacks. 
    For instance, on platforms like CSES, a memoized solution may fail to get accepted due to time limits, while an equivalent tabulated version with the same complexity passes successfully because it avoids recomputation and performs better in practice.
  </p>

  <p>The best way to do DP is understanding the intuition behind it via multiple examples like :</p>
  <section>
    <h3>
      <a href="https://cses.fi/problemset/task/1633" target="_blank">Dice Problem (CSES)</a>
    </h3>
    <p>
      Given a target sum <code>n</code>, you need to compute the total number of distinct sequences of dice rolls (each roll giving 1 to 6) that sum up to exactly <code>n</code>.
    </p>
    <p>
      This is a classic Dynamic Programming problem where the recurrence relation is:
    </p>
    <pre><code>
    f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4) + f(n-5) + f(n-6)
    </code></pre>
    <p>
      With the base case:
      <br>
      <code>f(0) = 1</code> — there's one way to make a sum of 0 (by doing nothing).
    </p>
    <p>
      For all negative values of <code>n</code>, we return 0, since it's not possible to reach negative sums with positive dice rolls.
    </p>
  </section>
  
  <a href="./dynamic_prog2.html" class="nextbtn">Next lesson</a>
</body>
</html>